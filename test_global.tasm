##########################
# struct Player {
# 	float		speed;
# 	uint32_t	health, ammo;
# };
# struct Player *g_pPlayer;
# g_pPlayer is defined in this script
# but its pointer value will be supplied from the host!
# that makes g_pPlayer a pointer to a host variable.
##########################
$stacksize 500
$global g_pPlayer, 8,	0
$global module_str, 19, "test_factorial.tbc"
$global factorial_str, 10, "factorial"

$native %Tagha_LoadModule ; void *Tagha_LoadModule(const char *);
$native %Tagha_InvokeFunc ; bool Tagha_InvokeFunc(void *, const char *, union Value *, size_t, union Value []);
$native %Tagha_FreeModule ; void Tagha_FreeModule(void **);

%main: {
	sub rsp, 32
	lea rgamal, g_pPlayer
	mov rgamal, [word rgamal]
	mov [long rgamal], 0x43960000 ; 300.f as a 32-bit int hex
	mov [long rgamal+4], 100 ; g_pPlayer->health = 100;
	mov [long rgamal+8], 32 ; g_pPlayer->ammo = 32;
	
	mov rbeth, 10000000 #1000000000 / 1000000 / 10000000
	lea rsemkath, module_str
	mov ralaf, 1
	syscall %Tagha_LoadModule
	mov [word rbp-24], ralaf ; module ptr is in ralaf, copy it to stack
	
	; load array
	mov [word rbp-16], 5
	lea rqof, [rbp-16]
	; load constant
	mov rsadhe, 1
	; load return value ptr.
	lea rpeh, [rbp-8]
	; load string of function we want to execute.
	lea r_eh, factorial_str
	; copy the module ptr to register semkath.
	mov rsemkath, [word rbp-24]
	
	; test dynamic loading function invocation overhead
.loop:
	mov ralaf, 5
	syscall %Tagha_InvokeFunc
	dec rbeth
	cmp rbeth, 0
	jz .loop
	
	lea rsemkath, [rbp-24]
	mov ralaf, 1
	syscall %Tagha_FreeModule
	mov ralaf, [word rbp-8]
	ret
}

