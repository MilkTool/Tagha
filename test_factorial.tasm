# manually set stack size
# directives start with $
# if stacksize isn't set, the default stacksize is 128 which will end up as
# 128 * 8 == 1024 bytes of stack size.
# also, the stack size will be aligned to a size of 8
# so 129 will not actually make a stack size of 129 * 8 bytes,
# 129 will be changed at runtime to 136 * 8
$stacksize 0xff

# global var named 'i' which is 12 bytes (struct) and is assigned the values after the bytesize.
$global i, 12,	0
$global n, 4, byte 0, byte 0, byte 0, byte 0x40 # alternative: long 0x40000000 or 1073741824

# global var for strings, number is string length WITH null terminator.
$global str, 30,	"bytecode says you suck hahaah"
$native %puts

# uint32_t factorial(const uint32_t i) {
#     if( i<=1 )
#         return 1;
#     return i * factorial(i-1);
# }

%main: {
	mov rsemkath, 5
	call %factorial
	#mov rsemkath, 0x40a00000 ; 5.f
	#call %factorial_float
	ret
}

%factorial: {
	mov	[long rbp-4], rsemkath
	
# if( i<=1 )
	cmp	[long rbp-4], 1
	jz	.cont
	
# return 1;
	mov ralaf, 1
	ret
	
.cont:
# return i * factorial(i-1);
	mov ralaf, [long rbp-4]
	sub ralaf, 1
	mov rsemkath, ralaf
	call %factorial
	mul ralaf, [long rbp-4]
	ret
}

%factorial_float: {
	sub	rsp, 16
	mov	[long rbp-4], rsemkath
	
# if( i<=1.f )
	cmpf	[long rbp-4], 0x3f800000 ; 1.f in int hex
	jz	.contflt
	
# return 1.f;
	mov ralaf, 0x3f800000
	ret
	
.contflt:
# return i * factorial_float(i-1.f);
	mov ralaf, [long rbp-4]
	subf long ralaf, 0x3f800000
	mov rsemkath, ralaf
	call %factorial_float
	mulf ralaf, [long rbp-4]
	ret
}
